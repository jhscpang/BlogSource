---
title: 一致性哈希技术
date: 2017-04-05 20:01:52
categories: 算法
tags:
	- 算法
	- 哈希
---

## 概述

在分布式的环境下有这样一个基本场景：比如你有N个缓存服务器做数据缓存，通用方法计算方法是计算object的hash值，然后均匀的映射到N个缓存服务器里，公式是：hash(object) % N。这样的计算方法在理想情况下可以工作的不错，但是现实中往往会改变缓存服务器的数量，那么通过上面这个公式计算出来的缓存映射就全部失效了。

优化上面遇到的问题的方法是使用一致性哈希算法。简单的说，一致性哈希算法要求在移除或添加一个缓存服务器时，它能够尽可能小的改变已存在key映射关系，尽可能的满足单调性的要求。单调性要求是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中，哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。

本文参考的帖子有如下几个:
http://blog.csdn.net/kinger0/article/details/49760751
http://blog.csdn.net/sparkliang/article/details/5279393

## 原理


结合下面的一致性哈希示意图，一致性哈希算法的基本步骤如下：

  1. 构造一个空间，想象成环状，例如网上常用的的0 ~ 2^32-1这个空间。
  2. 将服务器通过哈希函数映射到环上(如图中蓝色节点)，通常使用服务器ip或者服务器名作为hash函数的输入。
  3. 将对象object通过和上一步同样的哈希函数映射到环上(如图中橙色节点)。
  4. 将橙色节点顺时针(其实都是用逆时针感觉也行)找到第一个相遇的蓝色节点，这个橙色对象就存在这个蓝色节点上。

![一致性哈希示意图](/images/201704/一致性哈希示意图.png)

通过这个算法，如果图中在蓝色节点B和蓝色节点C中间加上一个蓝色节点M，那么只有M与B之间的橙色节点由存在C上改变成存在M上，其他未知的橙色节点的存储位置没变，这就是使用一致性哈希的好处。

但是，假设现在把蓝色节点B撤掉，那么原来存在B上的橙色节点全部要转移到C上，假如B上的数据非常多，那么C上就会出现数据过多，也就是热点。也叫数据倾斜。如下图所示。

![删除一个节点后的一致性哈希示意图](/images/201704/删除一个节点后的一致性哈希示意图.png)

## 优化

出现数据倾斜的原因是当B挂了以后，B上的的数据全部转到了C上，如果能让数据被分散的转移到多个机器上，那么问题就解决了。因此出现了虚拟节点的概念。

如下图所示，环上的服务器全部是虚拟节点，A1、A2上的数据实际是在A服务器上存储的，以此类推。这样假如B节点宕机了，那么B1、B2虚拟节点上的数据要转移到它们的下家，也就是D2、A1上，对应的实际服务器也就是D和A，这样就由两台服务器分担B上的数据压力。

![虚拟节点一致性哈希示意图](/images/201704/虚拟节点一致性哈希示意图.png)








